"""ReasoningBank: Procedural recipes for ontology exploration with RLM"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_reasoning_bank.ipynb.

# %% auto #0
__all__ = ['ONTOLOGY_RECIPES', 'Recipe', 'classify_task_type', 'retrieve_ontology_recipes', 'format_recipes_for_injection',
           'inject_context', 'rlm_run_enhanced', 'validate_memory_recipe_separation']

# %% ../nbs/06_reasoning_bank.ipynb #a282f136
from dataclasses import dataclass
from typing import Optional

# %% ../nbs/06_reasoning_bank.ipynb #fe04fdca
@dataclass
class Recipe:
    """A procedural recipe for ontology exploration.
    
    Recipes provide explicit step-by-step guidance on HOW to use ontology
    exploration tools to accomplish specific tasks.
    """
    id: str  # Unique identifier (e.g., 'recipe-1-describe-entity')
    title: str  # Human-readable title
    when_to_use: str  # When this recipe applies
    procedure: str  # Step-by-step markdown checklist
    expected_iterations: int  # Expected number of iterations to converge
    layer: int  # 0=sense, 1=core, 2=task-type, 3=ontology-specific
    task_types: list[str]  # Which task types this applies to
    ontology: Optional[str] = None  # None = universal, else ontology name
    
    def format_for_injection(self) -> str:
        """Format recipe for context injection."""
        lines = [
            f"### Recipe: {self.title}",
            "",
            f"**When to use:** {self.when_to_use}",
            "",
            f"**Expected iterations:** {self.expected_iterations}",
            "",
            "**Procedure:**",
            self.procedure
        ]
        return '\n'.join(lines)

# %% ../nbs/06_reasoning_bank.ipynb #d4162c3e
# Ontology-specific recipes only
# General strategies are now in procedural_memory.bootstrap_general_strategies()

ONTOLOGY_RECIPES = [
    # Placeholder for ontology-specific patterns
    # Example:
    # Recipe(
    #     id='prov-activity-entity-pattern',
    #     title='Activity-Entity Relationships in PROV',
    #     ontology='prov',  # PROV-specific
    #     procedure='In PROV, Activities relate to Entities via...'
    # )
]


# %% ../nbs/06_reasoning_bank.ipynb #0feed99e
def classify_task_type(query: str) -> str:
    """Classify query into task type for recipe selection.
    
    Args:
        query: User query string
        
    Returns:
        Task type: 'entity_discovery', 'entity_description', 'hierarchy',
                  'property_discovery', 'pattern_search', 'relationship_discovery'
    """
    query_lower = query.lower()
    
    # Hierarchy queries
    if any(word in query_lower for word in ['subclass', 'superclass', 'parent', 'child', 'hierarchy']):
        return 'hierarchy'
    
    # Property queries
    if any(word in query_lower for word in ['property', 'properties', 'domain', 'range', 'relates']):
        return 'property_discovery'
    
    # Relationship queries
    if any(word in query_lower for word in ['path', 'connects', 'relationship', 'related']):
        return 'relationship_discovery'
    
    # Pattern search
    if any(word in query_lower for word in ['find all', 'search for', 'list', 'matching']):
        return 'pattern_search'
    
    # Entity description ("What is X?")
    if any(word in query_lower for word in ['what is', 'describe', 'tell me about']):
        return 'entity_description'
    
    # Default to entity discovery
    return 'entity_discovery'


def retrieve_ontology_recipes(ontology: str = None, k: int = 2) -> list[Recipe]:
    """Retrieve ontology-specific recipes.
    
    Args:
        ontology: Ontology name (e.g., 'prov', 'sio') or None for all
        k: Number of recipes to retrieve
        
    Returns:
        List of relevant Recipe objects
    """
    if not ONTOLOGY_RECIPES:
        return []
    
    # Filter by ontology if specified
    if ontology:
        relevant = [
            recipe for recipe in ONTOLOGY_RECIPES
            if recipe.ontology == ontology or recipe.ontology is None
        ]
    else:
        relevant = ONTOLOGY_RECIPES[:]
    
    return relevant[:k]


def format_recipes_for_injection(recipes: list[Recipe]) -> str:
    """Format recipes as markdown for context injection.
    
    Args:
        recipes: List of Recipe objects
        
    Returns:
        Formatted markdown string
    """
    if not recipes:
        return ""
    
    sections = ["## Procedural Recipes", ""]
    
    for recipe in recipes:
        sections.append(recipe.format_for_injection())
        sections.append("")  # Blank line between recipes
    
    return '\n'.join(sections)

# %% ../nbs/06_reasoning_bank.ipynb #f8d2bcdc
def inject_context(
    query: str,
    base_context: str,
    sense: dict = None,
    memory_store = None,
    ontology: str = None,
    max_memories: int = 3,
    max_task_recipes: int = 2
) -> str:
    """Build complete context with sense + memories + recipes.
    
    Injection order:
    1. Sense card (Layer 0) - if provided
    2. Retrieved memories (Layer 1) - general strategies from memory_store
    3. Task-type recipes (Layer 2) - ontology-specific patterns
    4. Base context - original graph summary
    
    Args:
        query: User query
        base_context: Base context string (e.g., GraphMeta.summary())
        sense: Structured sense document (from build_sense_structured)
        memory_store: MemoryStore with general strategies
        ontology: Optional ontology name for ontology-specific recipes
        max_memories: Maximum memories to retrieve
        max_task_recipes: Maximum task-type recipes to inject
        
    Returns:
        Enhanced context string
    """
    from rlm.ontology import get_sense_context
    
    sections = []
    
    # Layer 0: Sense card (if provided)
    if sense:
        sense_ctx = get_sense_context(query, sense)
        sections.append(sense_ctx)
    
    # Layer 1: Retrieved memories (general strategies)
    if memory_store:
        from rlm.procedural_memory import retrieve_memories, format_memories_for_injection
        memories = retrieve_memories(memory_store, query, k=max_memories)
        if memories:
            sections.append(format_memories_for_injection(memories))
    
    # Layer 2: Ontology-specific recipes (if any)
    if ontology and ONTOLOGY_RECIPES:
        ontology_recipes = [
            r for r in ONTOLOGY_RECIPES
            if r.ontology == ontology or r.ontology is None
        ]
        if ontology_recipes:
            sections.append(format_recipes_for_injection(ontology_recipes[:max_task_recipes]))
    
    # Layer 3: Base context (original)
    if base_context:
        sections.append("## Base Context")
        sections.append("")
        sections.append(base_context)
    
    return '\n\n'.join(sections)


# %% ../nbs/06_reasoning_bank.ipynb #d28fe844
def rlm_run_enhanced(
    query: str,
    context: str,
    ns: dict = None,
    sense: dict = None,
    memory_store = None,
    ontology: str = None,
    **kwargs
) -> tuple:
    """RLM run with sense and memory injection.
    
    This is a drop-in replacement for rlm_run() that automatically
    enhances context with:
    - Layer 0: Structured sense card
    - Layer 1: Retrieved procedural memories (general strategies)
    - Layer 2: Ontology-specific recipes
    
    Args:
        query: User query
        context: Base context (e.g., GraphMeta.summary())
        ns: Namespace dict
        sense: Structured sense document (from build_sense_structured)
        memory_store: MemoryStore with general strategies
        ontology: Optional ontology name
        **kwargs: Additional arguments passed to rlm_run()
        
    Returns:
        (answer, iterations, final_ns) - same as rlm_run()
    """
    from rlm.core import rlm_run
    
    # Build enhanced context with layered injection
    enhanced_context = inject_context(
        query=query,
        base_context=context,
        sense=sense,
        memory_store=memory_store,
        ontology=ontology
    )
    
    # Call base rlm_run with enhanced context
    return rlm_run(query, enhanced_context, ns=ns, **kwargs)


# %% ../nbs/06_reasoning_bank.ipynb #539d0129
def validate_memory_recipe_separation(memory_store) -> dict:
    """Ensure general strategies aren't duplicated in ONTOLOGY_RECIPES.
    
    Validates:
    - No title overlap between universal memories and ontology recipes
    - All ONTOLOGY_RECIPES have ontology field set (domain-specific)
    
    Args:
        memory_store: MemoryStore (typically with bootstrap strategies)
    
    Returns:
        Dictionary with validation results
    """
    # Get titles from memory store (bootstrap strategies)
    memory_titles = set(
        m.title.lower() 
        for m in memory_store.memories 
        if 'universal' in m.tags
    )
    
    # Get titles from ONTOLOGY_RECIPES
    recipe_titles = set(r.title.lower() for r in ONTOLOGY_RECIPES)
    
    # Check for overlap
    overlap = memory_titles & recipe_titles
    
    # Check ONTOLOGY_RECIPES are truly ontology-specific
    ontology_specific = all(
        r.ontology is not None
        for r in ONTOLOGY_RECIPES
    ) if ONTOLOGY_RECIPES else True  # Empty is valid
    
    return {
        'valid': len(overlap) == 0 and ontology_specific,
        'overlap_count': len(overlap),
        'overlapping_titles': list(overlap),
        'all_recipes_have_ontology': ontology_specific,
        'ontology_recipes_count': len(ONTOLOGY_RECIPES)
    }

