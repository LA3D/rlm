"""Enables 'retrieve example → adapt → run → inspect' workflow for discovering how to query unfamiliar datasets."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_shacl_examples.ipynb.

# %% auto 0
__all__ = ['SHACLIndex', 'detect_shacl', 'extract_keywords', 'build_shacl_index', 'describe_shape', 'search_shapes',
           'shape_constraints']

# %% ../nbs/06_shacl_examples.ipynb 2
from dataclasses import dataclass, field
from typing import Dict, List, Optional
from rdflib import Graph, Namespace, RDF, RDFS, URIRef, Literal
from rdflib.namespace import SH

# %% ../nbs/06_shacl_examples.ipynb 4
@dataclass
class SHACLIndex:
    """Index of SHACL shapes for retrieval.
    
    Attributes:
        shapes: List of shape URIs
        targets: Mapping from shape URI to target class URIs
        properties: Mapping from shape URI to property constraint dicts
        keywords: Inverted index from keyword to shape URIs
        paradigm: SHACL usage paradigm ('validation', 'shacl-first', 'mixed')
    """
    shapes: List[str] = field(default_factory=list)
    targets: Dict[str, List[str]] = field(default_factory=dict)
    properties: Dict[str, List[dict]] = field(default_factory=dict)
    keywords: Dict[str, List[str]] = field(default_factory=dict)
    paradigm: str = 'unknown'

    def summary(self) -> str:
        """Return bounded summary of index."""
        return f"SHACLIndex: {len(self.shapes)} shapes, {len(self.keywords)} keywords, paradigm={self.paradigm}"

# %% ../nbs/06_shacl_examples.ipynb 6
def detect_shacl(graph: Graph) -> dict:
    """Detect SHACL content in a graph.

    Args:
        graph: RDF graph to analyze

    Returns:
        Dict with:
            has_shacl: True if any SHACL patterns found
            node_shapes: Count of sh:NodeShape instances
            property_shapes: Count of sh:PropertyShape instances
            paradigm: 'validation', 'shacl-first', or 'mixed'
    """
    # Count SHACL shape types
    node_shapes = list(graph.subjects(RDF.type, SH.NodeShape))
    property_shapes = list(graph.subjects(RDF.type, SH.PropertyShape))
    
    has_shacl = len(node_shapes) > 0 or len(property_shapes) > 0
    
    if not has_shacl:
        return {
            'has_shacl': False,
            'node_shapes': 0,
            'property_shapes': 0,
            'paradigm': 'none'
        }
    
    # Detect paradigm
    DASH = Namespace("http://datashapes.org/dash#")
    dash_shape_classes = list(graph.subjects(RDF.type, DASH.ShapeClass))
    
    # Check if shapes are also OWL classes (mixed paradigm)
    OWL = Namespace("http://www.w3.org/2002/07/owl#")
    shapes_as_classes = any(
        (s, RDF.type, OWL.Class) in graph or 
        (s, RDFS.subClassOf, None) in graph
        for s in node_shapes
    )
    
    if dash_shape_classes:
        paradigm = 'shacl-first'
    elif shapes_as_classes:
        paradigm = 'mixed'
    else:
        paradigm = 'validation'
    
    return {
        'has_shacl': True,
        'node_shapes': len(node_shapes),
        'property_shapes': len(property_shapes),
        'paradigm': paradigm
    }

# %% ../nbs/06_shacl_examples.ipynb 8
def extract_keywords(graph: Graph, shape: URIRef, target_classes: List[str], props: List[dict]) -> List[str]:
    """Extract searchable keywords from a shape.
    
    Args:
        graph: RDF graph containing the shape
        shape: Shape URI
        target_classes: Target class URIs
        props: Property constraint dicts
    
    Returns:
        List of lowercase keywords
    """
    keywords = set()
    
    # Extract from shape URI local name
    shape_local = str(shape).split('/')[-1].split('#')[-1]
    keywords.add(shape_local.lower())
    
    # Extract from labels
    for label in graph.objects(shape, RDFS.label):
        keywords.add(str(label).lower())
    
    # Extract from target class local names
    for tc in target_classes:
        tc_local = tc.split('/')[-1].split('#')[-1]
        keywords.add(tc_local.lower())
    
    # Extract from property paths
    for prop in props:
        if prop.get('path'):
            path_local = prop['path'].split('/')[-1].split('#')[-1]
            keywords.add(path_local.lower())
    
    return list(keywords)

# %% ../nbs/06_shacl_examples.ipynb 10
def build_shacl_index(graph: Graph) -> SHACLIndex:
    """Build searchable index from SHACL shapes in graph.
    
    Args:
        graph: RDF graph containing SHACL shapes
    
    Returns:
        SHACLIndex with indexed shapes
    """
    detection = detect_shacl(graph)
    
    if not detection['has_shacl']:
        return SHACLIndex(paradigm='none')
    
    shapes = []
    targets = {}
    properties = {}
    keywords = {}
    
    # Index all NodeShapes
    for shape in graph.subjects(RDF.type, SH.NodeShape):
        shape_uri = str(shape)
        shapes.append(shape_uri)
        
        # Get target classes
        target_classes = [str(t) for t in graph.objects(shape, SH.targetClass)]
        targets[shape_uri] = target_classes
        
        # Get property constraints
        props = []
        for prop_node in graph.objects(shape, SH.property):
            path = graph.value(prop_node, SH.path)
            datatype = graph.value(prop_node, SH.datatype)
            node_kind = graph.value(prop_node, SH.nodeKind)
            min_count = graph.value(prop_node, SH.minCount)
            max_count = graph.value(prop_node, SH.maxCount)
            class_constraint = graph.value(prop_node, SH['class'])
            
            props.append({
                'path': str(path) if path else None,
                'datatype': str(datatype) if datatype else None,
                'nodeKind': str(node_kind) if node_kind else None,
                'minCount': int(min_count) if min_count else None,
                'maxCount': int(max_count) if max_count else None,
                'class': str(class_constraint) if class_constraint else None,
            })
        properties[shape_uri] = props
        
        # Build keyword index
        shape_keywords = extract_keywords(graph, shape, target_classes, props)
        for kw in shape_keywords:
            if kw not in keywords:
                keywords[kw] = []
            if shape_uri not in keywords[kw]:
                keywords[kw].append(shape_uri)
    
    return SHACLIndex(
        shapes=shapes,
        targets=targets,
        properties=properties,
        keywords=keywords,
        paradigm=detection['paradigm']
    )

# %% ../nbs/06_shacl_examples.ipynb 12
def describe_shape(index: SHACLIndex, shape_uri: str, limit: int = 10) -> dict:
    """Get bounded description of a SHACL shape.

    Args:
        index: SHACL index to query
        shape_uri: URI of shape to describe
        limit: Maximum number of properties to return

    Returns:
        Dict with:
            uri: Shape URI
            targets: List of target class URIs
            properties: First `limit` property constraints
            property_count: Total property count
            truncated: True if property list was truncated
    """
    if shape_uri not in index.targets:
        return {'error': f'Shape {shape_uri} not found in index'}

    props = index.properties.get(shape_uri, [])
    return {
        'uri': shape_uri,
        'targets': index.targets[shape_uri],
        'properties': props[:limit],
        'property_count': len(props),
        'truncated': len(props) > limit
    }

# %% ../nbs/06_shacl_examples.ipynb 13
def search_shapes(index: SHACLIndex, keyword: str, limit: int = 5) -> list:
    """Find shapes matching keyword.

    Args:
        index: SHACL index to search
        keyword: Search term
        limit: Maximum number of results

    Returns:
        List of dicts with:
            uri: Shape URI
            targets: Target class URIs
            matched_keyword: The keyword that matched
    """
    keyword_lower = keyword.lower()
    matches = []

    for kw, shape_uris in index.keywords.items():
        if keyword_lower in kw.lower():
            for uri in shape_uris:
                matches.append({
                    'uri': uri,
                    'targets': index.targets.get(uri, []),
                    'matched_keyword': kw
                })

    # Dedupe by URI, keep first match
    seen = set()
    unique = []
    for m in matches:
        if m['uri'] not in seen:
            seen.add(m['uri'])
            unique.append(m)

    return unique[:limit]

# %% ../nbs/06_shacl_examples.ipynb 14
def shape_constraints(index: SHACLIndex, shape_uri: str) -> str:
    """Get human-readable property constraints for a shape.
    
    Args:
        index: SHACL index to query
        shape_uri: URI of shape
    
    Returns:
        Formatted string with property constraints
    """
    if shape_uri not in index.properties:
        return f"Shape {shape_uri} not found in index"

    lines = [f"Constraints for {shape_uri.split('/')[-1].split('#')[-1]}:"]
    
    props = index.properties[shape_uri]
    if not props:
        lines.append("  (no property constraints)")
        return '\n'.join(lines)
    
    for prop in props:
        path = prop.get('path', '?')
        path_local = path.split('/')[-1].split('#')[-1] if path else '?'
        
        parts = []
        if prop.get('datatype'):
            dt_local = prop['datatype'].split('#')[-1]
            parts.append(f"type={dt_local}")
        if prop.get('class'):
            cls_local = prop['class'].split('/')[-1].split('#')[-1]
            parts.append(f"class={cls_local}")
        if prop.get('nodeKind'):
            nk_local = prop['nodeKind'].split('#')[-1]
            parts.append(f"kind={nk_local}")
        if prop.get('minCount') is not None:
            parts.append(f"min={prop['minCount']}")
        if prop.get('maxCount') is not None:
            parts.append(f"max={prop['maxCount']}")
        
        constraint = ', '.join(parts) if parts else 'no constraints'
        lines.append(f"  {path_local}: {constraint}")

    return '\n'.join(lines)
