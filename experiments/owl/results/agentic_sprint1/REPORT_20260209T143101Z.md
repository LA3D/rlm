# Agentic OWL+SHACL Sprint-1 Report (Post-Fix Trajectory Run)

## Run Metadata

- Timestamp: `20260209T143101Z`
- Objective: Evaluate sprint-1 (`CQ1..CQ5`) after CQ-scope guards, focused-validation global fallback, report-text throttling, signature deltas, post-CQ closure pass, and immediate principle compilation.
- Main model: `anthropic/claude-sonnet-4-5-20250929`
- Sub-model: `anthropic/claude-haiku-4-5-20251001`
- Ontology input: `ontology/core-vocabulary.ttl`
- SHACL input: `ontology/core-shapes.ttl`
- Runner: `experiments/owl/agentic_owl_runner.py`

## Repro Command

```bash
~/uvws/.venv/bin/python experiments/owl/agentic_owl_runner.py \
  --ontology-path ontology/core-vocabulary.ttl \
  --shapes-path ontology/core-shapes.ttl \
  --out-dir experiments/owl/results/agentic_sprint1
```

## Artifacts

- Summary: `experiments/owl/results/agentic_sprint1/summary_20260209T143101Z.json`
- Trajectory JSONL: `experiments/owl/results/agentic_sprint1/trajectory_20260209T143101Z.jsonl`
- Final graph snapshot: `experiments/owl/results/agentic_sprint1/working_graph_20260209T143101Z.ttl`

## Headline Results

- CQ pass rate: `5/5` (`100%`)
- Passed: `CQ1`, `CQ2`, `CQ3`, `CQ4`, `CQ5`
- Final SHACL conformance: `false`
- Final SHACL validation results: `14`
- Final graph size: `125` triples
- Total tokens: `346,428`
- Total cost: `1.307616`
- Total large returns: `30`
- Memory write-back: `5` episodes, `5` compiled principles

## Comparative Analysis

### Versus Previous Run (`20260209T133852Z`)

| Metric | Previous | Current | Delta |
|---|---:|---:|---:|
| CQ pass rate | `5/5` | `5/5` | `0` |
| Final SHACL results | `15` | `14` | `-1` |
| Total tokens | `490,386` | `346,428` | `-143,958` |
| Total cost | `1.813134` | `1.307616` | `-0.505518` |
| Large returns | `24` | `30` | `+6` |
| Iterations (sum) | `55` | `40` | `-15` |
| Principles | `0` | `5` | `+5` |
| Episodes | `5` | `5` | unchanged |

### SHACL Read Behavior Delta (`trajectory` tool-call view)

| Metric | Previous | Current | Delta |
|---|---:|---:|---:|
| `handle_read_window` calls | `24` | `3` | `-21` |
| Reads of `shacl_report_text` | `20` | `2` | `-18` |
| `include_text=True` reads | `24` | `3` | `-21` |

## Per-CQ Outcomes

| CQ | Passed | Iterations | Tokens | Cost | Large Returns | Notable Operators |
|---|---:|---:|---:|---:|---:|---|
| CQ1 | true | 6 | 44,871 | 0.169749 | 4 | `op_set_single_literal`, `op_assert_type` |
| CQ2 | true | 6 | 42,617 | 0.156639 | 3 | `op_add_literal`, `op_assert_type`, `op_add_iri_link` |
| CQ3 | true | 6 | 42,798 | 0.162870 | 4 | `op_assert_type`, `op_add_literal` |
| CQ4 | true | 10 | 74,106 | 0.269946 | 6 | `op_assert_type`, `op_add_iri_link` |
| CQ5 | true | 12 | 142,036 | 0.548412 | 13 | `op_add_iri_link`, `op_add_literal`, `op_remove_iri_link`, `op_set_single_literal` |

## Trajectory Statistics

- Total events: `318`
- Event mix:
  - `run_start`: `5`
  - `run_complete`: `5`
  - `iteration`: `40`
  - `tool_call`: `134`
  - `tool_result`: `134`
- Top tool calls (global):
  - `op_add_iri_link`: `24`
  - `ontology_node_outgoing`: `16`
  - `op_add_literal`: `15`
  - `ontology_validate_focus`: `14`
  - `cq_eval`: `13`
  - `op_assert_type`: `8`
- Guardrail activations:
  - `report_text_read_blocked`: `1`
  - `validation_without_graph_delta`: `1`
  - `repeated_handle_read_blocked`: `0`
  - `cq_scope_violation`: `0` observed in this run

## Behavioral Findings

1. CQ-local operation is materially tighter:
   - Calls and iterations dropped while maintaining `5/5` CQ pass.
   - Cross-CQ drifting behavior seen in prior runs did not manifest in this trajectory.

2. SHACL feedback is now mostly symbolic:
   - `handle_read_window` usage collapsed (`24 -> 3`), including large reductions in `report_text_ref` reads.
   - Focus-zero fallback (`global_signature_hint`) appears and is used.

3. Memory pipeline now compiles principles:
   - End-of-run memory shows `5` principles compiled from successful CQ episode patterns.
   - This closes the previous gap where only episodes were written.

4. Remaining cost pressure is concentrated in CQ5:
   - CQ5 still dominates operator churn and large returns.
   - Edit pattern indicates repeated add/remove/repair loops on profile resource descriptors.

5. Post-CQ global closure currently does not execute meaningful repairs:
   - `global_closure.steps` are `noop` for all CQs in this run.
   - The first signature path often appears as non-actionable blank-node-like values in closure heuristics, so deterministic mapping does not fire.

## Root-Cause Interpretation

- The implemented fixes improved agentic behavior quality (fewer loops, fewer raw report reads, lower cost, principle compilation).
- The remaining SHACL gap (`14` results, non-conformant) is less about CQ reasoning and more about closure-policy coverage:
  - closure mapping from signature `(shape/path/component)` to deterministic repair is still incomplete,
  - especially when `path` is not a stable predicate IRI for operator selection.

## Recommended Next Fixes

1. Make closure dispatch signature-first (not path-first):
   - Dispatch on `(constraint_component, source_shape, focus_node class)` with explicit handler tables.
   - Avoid treating opaque/blank-node `path` as primary routing input.

2. Add targeted CQ5 closure operators:
   - Operators for `dcat:mediaType` datatype normalization and profile/resource role/artifact/cardinality cleanup.
   - Prefer idempotent “set/normalize” operators over add/remove ping-pong loops.

3. Expand global closure loop observability:
   - Log closure step `before/after` signature deltas and stop only when no negative deltas remain.
   - Persist closure-step outcomes into episode payload to improve principle quality.

4. Tighten large-return control specifically for CQ5:
   - Clamp verbose node inspections and promote compact signature/row summaries.
   - Require symbolic extraction from `violations_ref` before any further payload reads.

5. Validate principle utility on rerun:
   - Add a “memory-on vs memory-off” A/B over sprint-1 to confirm compiled principles reduce CQ5 operator churn.

## Conclusion

This run confirms the architecture fixes are moving the system in the right direction: same `5/5` CQ success with materially lower tokens/cost, much lower raw SHACL report reading, and working principle compilation. The main unresolved issue is global SHACL closure quality (still `14` violations), which now appears to be a closure-dispatch coverage problem rather than an RLM symbolic-memory compliance problem.
