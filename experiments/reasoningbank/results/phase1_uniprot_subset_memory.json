[{"id": "9ac046ac3717", "title": "Selecting All Instances of a Specific Class Type", "desc": "Strategy for: Select all taxa from the UniProt taxonomy", "content": "When tasked with retrieving all entities of a particular type from a knowledge base:\n\n1. **Identify the target class**: Determine the RDF class that represents the entity type you want to retrieve (e.g., `up:Taxon` for taxonomy entries).\n\n2. **Use the basic class membership pattern**: Construct a SPARQL query using the simple triple pattern:\n   ```sparql\n   SELECT DISTINCT ?entity\n   WHERE {\n     ?entity a <TargetClass> .\n   }\n   ```\n   Where `?entity` is your variable and `<TargetClass>` is the specific class (e.g., `up:Taxon`).\n\n3. **Apply DISTINCT**: Always use `SELECT DISTINCT` to avoid duplicate results, as entities may have multiple statements that match the pattern.\n\n4. **Verification approach**: Before finalizing, you can:\n   - Count total instances using `COUNT(DISTINCT ?entity)` to verify the result set size\n   - Sample a few instances with `LIMIT` to confirm they are the correct entity type\n   - Check for optional properties (like names or labels) to validate entity structure\n\nThis pattern works for any well-defined class in an RDF/OWL ontology where entities are explicitly typed using `rdf:type` (abbreviated as `a`).", "src": "success", "tags": []}, {"id": "2c5ad7c11725", "title": "UniProt Mnemonic Lookup Using up:mnemonic Predicate", "desc": "Strategy for: Select the UniProtKB entry with the mnemonic 'A4_H", "content": "When querying UniProtKB entries by their mnemonic (entry name):\n\n1. **Use the correct predicate**: The UniProt RDF schema uses `up:mnemonic` as the predicate for entry mnemonics (not `up:name`, `rdfs:label`, or `skos:prefLabel`).\n\n2. **Query pattern**: Structure your SPARQL query as:\n   ```sparql\n   PREFIX up: <http://purl.uniprot.org/core/>\n   SELECT ?entry WHERE {\n     ?entry up:mnemonic '<MNEMONIC_VALUE>' .\n   }\n   ```\n\n3. **Key elements**:\n   - Declare the UniProt core namespace: `PREFIX up: <http://purl.uniprot.org/core/>`\n   - Use `?entry` as the subject variable to capture the full UniProtKB entry URI\n   - Match against `up:mnemonic` predicate with the exact mnemonic string as a literal value\n   - The mnemonic value should be enclosed in single quotes as a string literal\n\n4. **Expected result**: The query returns the full UniProt URI (e.g., `http://purl.uniprot.org/uniprot/P05067`) for the entry matching the specified mnemonic.\n\nThis pattern works for any UniProtKB mnemonic lookup by simply replacing the mnemonic value in the query.", "src": "success", "tags": []}, {"id": "a8efaf148be2", "title": "Classifying entities using subclass types with UNION and FILTER NOT EXISTS", "desc": "Strategy for: List all UniProtKB proteins and if they are review", "content": "When you need to classify entities based on whether they belong to a specific subclass or only to the parent class:\n\n1. **Identify the class hierarchy**: Determine if there's a parent class (e.g., `up:Protein`) and a more specific subclass (e.g., `up:Reviewed_Protein`)\n\n2. **Use UNION to create two separate branches**:\n   - First branch: Match entities that are instances of the specific subclass\n   - Second branch: Match entities that are instances of the parent class but NOT the subclass\n\n3. **Apply FILTER NOT EXISTS in the second branch**: Use `FILTER NOT EXISTS { ?entity a SpecificSubclass }` to exclude entities that belong to the subclass, ensuring you only get parent-class-only instances\n\n4. **Use BIND to assign labels**: In each UNION branch, use `BIND(\"label\" AS ?variable)` to assign descriptive status labels that distinguish between the two categories\n\n5. **Structure the query**:\n   ```\n   SELECT ?entity ?status WHERE {\n     {\n       ?entity a SpecificSubclass .\n       BIND(\"specific label\" AS ?status)\n     }\n     UNION\n     {\n       ?entity a ParentClass .\n       FILTER NOT EXISTS { ?entity a SpecificSubclass }\n       BIND(\"general label\" AS ?status)\n     }\n   }\n   ```\n\nThis pattern ensures complete coverage: entities are classified as either belonging to the specific subclass or only to the parent class, with no overlap or omissions.", "src": "success", "tags": []}, {"id": "1999fb877d96", "title": "Finding Taxa with Host Relationships Using up:host Property", "desc": "Strategy for: Find taxon records that are known to have part of ", "content": "When searching for organisms that have part of their life cycle in other organisms (parasites, symbionts, pathogens), use the `up:host` property to identify taxon records with host relationships:\n\n1. Query the `up:Taxon` class to find taxonomic records\n2. Filter for taxa that have the `up:host` property defined\n3. Use the pattern: `?taxon a up:Taxon . ?taxon up:host ?host .`\n4. This property directly indicates organisms that depend on or interact with host organisms during their life cycle\n\nThe `up:host` property is the key indicator in UniProt for organisms with host-dependent life cycles, including:\n- Viruses that infect host cells\n- Parasitic organisms\n- Symbiotic organisms\n- Pathogens\n\nThis approach works because UniProt explicitly models host relationships using the `up:host` predicate, making it a reliable filter for identifying organisms with host-dependent biology.", "src": "success", "tags": []}, {"id": "d4331e00bcb6", "title": "Retrieving UniProt Recommended Protein Full Names via Intermediate Name Object", "desc": "Strategy for: The recommended protein full names for UniProtKB e", "content": "When querying for recommended protein full names in UniProtKB:\n\n1. **Identify the main entity type**: Start with `?protein a up:Protein` to get all protein entries\n\n2. **Navigate through the intermediate name object**: UniProt uses a two-step property path for recommended names:\n   - First, connect protein to its recommended name object: `?protein up:recommendedName ?recName`\n   - Then, extract the full name from that object: `?recName up:fullName ?fullName`\n\n3. **Use the complete property chain**: The pattern is:\n   ```\n   ?protein up:recommendedName ?intermediateObject .\n   ?intermediateObject up:fullName ?fullName .\n   ```\n\n4. **Key insight**: The recommended name is NOT a direct property of the protein entity. It requires traversing through an intermediate structured name object (`up:recommendedName`) before accessing the actual full name string (`up:fullName`).\n\n5. **Apply this pattern**: This two-hop property path pattern (entity \u2192 intermediate object \u2192 final value) is common in UniProt's RDF schema for structured name information.\n\nThis procedure is specifically based on the SPARQL pattern that successfully retrieved recommended protein full names using the `up:recommendedName` and `up:fullName` properties in sequence.", "src": "success", "tags": []}, {"id": "91b3e91a7a9d", "title": "Confusing Creation Date with Integration Date in UniProtKB", "desc": "Pitfall for: Select all UniProtKB entries that were integrated ", "content": "The trajectory failed because it used `up:created` predicate to find entries, but the task specifically asked for entries that were \"integrated\" on a particular date. In UniProtKB, \"created\" and \"integrated\" are distinct concepts:\n\n- `up:created`: Refers to when the entry was first created in the database\n- Integration date: Refers to when the entry was integrated/added to UniProtKB (often represented by predicates like `up:modified`, `up:annotation`, or specific integration-related properties)\n\n**How to avoid this pitfall:**\n1. Carefully distinguish between similar temporal concepts (created, modified, integrated, updated)\n2. When encountering domain-specific terminology like \"integrated,\" explore the ontology to find the exact predicate that matches this concept\n3. Use `endpoint_info()` or sample queries to verify which predicates are available and their precise meanings\n4. Test with `sparql_slice()` to examine actual data and confirm the predicate returns entries matching the intended temporal concept\n5. When in doubt, query for multiple temporal predicates and compare results to identify which one matches the task requirement\n\nThe correct approach would have been to identify the specific predicate used for integration dates in UniProtKB (possibly `up:modified` or checking annotation dates) rather than assuming `up:created` was the right property.", "src": "failure", "tags": []}, {"id": "2919c5b2db81", "title": "Querying Hierarchical Taxonomy with Transitive Subclass Relationships", "desc": "Strategy for: Select all bacterial taxa and their scientific nam", "content": "When querying for all members of a taxonomic group in UniProt:\n\n1. **Use transitive property paths for hierarchy traversal**: Apply `rdfs:subClassOf+` to find all descendants in the taxonomy tree, not just direct children. The `+` operator ensures one-or-more hops through the hierarchy.\n\n2. **Anchor to the parent taxon URI**: Reference the parent taxon using its specific URI (e.g., `taxon:2` for Bacteria) as the object of the subClassOf relationship pattern.\n\n3. **Filter by resource type**: Include `?taxon a up:Taxon` to ensure results are actual Taxon instances, not other related entities.\n\n4. **Extract required properties**: Use the `up:scientificName` predicate to retrieve the scientific name for each taxon.\n\n5. **Structure the WHERE clause pattern**:\n   - `?taxon rdfs:subClassOf+ <parent_taxon_uri>` (finds all descendants)\n   - `?taxon a up:Taxon` (type constraint)\n   - `?taxon up:scientificName ?scientificName` (property extraction)\n\nThis pattern efficiently retrieves complete taxonomic subtrees by leveraging SPARQL's transitive closure operators rather than recursive queries.", "src": "success", "tags": []}, {"id": "4b847b276fd8", "title": "Retrieving UniProtKB Protein-Disease Associations via Disease Annotations", "desc": "Strategy for: List all UniProtKB proteins and the diseases are a", "content": "To retrieve proteins and their associated diseases from UniProtKB:\n\n1. **Identify proteins with disease annotations**: Start by selecting entities of type `up:Protein` that have annotations (`up:annotation`) of type `up:Disease_Annotation`.\n\n2. **Navigate the annotation structure**: From each disease annotation, follow the `up:disease` predicate to reach the disease entity itself.\n\n3. **Extract disease labels**: Use `skos:prefLabel` on the disease entity to retrieve the human-readable disease name, rather than attempting to use UniProt-specific label predicates.\n\n4. **Structure the query pattern**:\n   - `?protein a up:Protein` - Find all proteins\n   - `?protein up:annotation ?annotation` - Get their annotations\n   - `?annotation a up:Disease_Annotation` - Filter for disease annotations\n   - `?annotation up:disease ?disease` - Navigate to disease entity\n   - `?disease skos:prefLabel ?diseaseName` - Get disease name using SKOS vocabulary\n\n5. **Key insight**: UniProtKB uses the SKOS (Simple Knowledge Organization System) vocabulary for disease labels, not UniProt-specific predicates. The disease entities are separate resources linked through the annotation object.\n\nThis pattern creates a chain through the annotation layer to connect proteins to their associated disease names, leveraging the intermediate Disease_Annotation type to establish the relationship.", "src": "success", "tags": []}, {"id": "abc3599e9f47", "title": "Finding Longest Text Property Using STRLEN and ORDER BY", "desc": "Strategy for: Find longest comment text associated with a UniPro", "content": "When you need to find the longest text value among multiple instances of a property:\n\n1. **Query Pattern Structure**:\n   - Select the entity, the text property, and calculate its length using STRLEN()\n   - Use the pattern: `SELECT ?entity ?textProperty (STRLEN(?textProperty) as ?length)`\n\n2. **Core Triple Patterns**:\n   - Connect the main entity to the target resource via appropriate property\n   - Filter by specific type using `?resource a <TypeClass>`\n   - Retrieve the text property (often rdfs:comment or similar)\n\n3. **Sorting and Limiting**:\n   - Order results by the calculated length in descending order: `ORDER BY DESC(?length)`\n   - Limit to 1 result to get only the longest: `LIMIT 1`\n\n4. **Specific Pattern Used**:\n   ```\n   ?mainEntity <property> ?targetResource .\n   ?targetResource a <SpecificType> .\n   ?targetResource <textProperty> ?text .\n   ORDER BY DESC(STRLEN(?text))\n   LIMIT 1\n   ```\n\nThis approach efficiently finds the maximum-length text without retrieving all data and processing it externally. The SPARQL engine handles the length calculation and sorting, returning only the longest result.", "src": "success", "tags": []}]